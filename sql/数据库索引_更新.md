## 数据库索引

### 准备

- 索引的数据结构（索引的类型，为什么快）
- 聚集索引与非聚集索引
- 创建索引的规则
- 不能命中索引的情况
- 联合索引

### 什么是索引：

优化查询，查询更快...

#### 索引的目的：

为了提高数据查询的效率，就像书的目录一样，一本 500 页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。

#### 如何建立目录：

如何存储这个目录，然后能实现快速查找和插入的需求，数组？哈希表？搜索树？索引实际是一种能提高读写效率的数据结构，一般都采用B+树（多路平衡搜索树）这种数据结构，这个B+树会存储你索引字段的所有数据。当你查找某条记录的时候，之前先查找这个B+树的数据，然后再去查找数据库整行的数据，那又是怎么通过索引字段找到数据库表整行数据的？

#### 为什么是树，为什么是B+树：

- 哈希表?

做区间查询时速度很慢，只适用于等值查询的场景,分组：group by？排序：order by？

- 数组？

数组修改的时候效率很低，只适用于数据不会修改的情形

- 树？  

  - 区间查询？
  - 高效的读，写？
  - 二叉树->B-树->B+树  

   [数据库索引，到底是什么做的？](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651961486&idx=1&sn=b319a87f87797d5d662ab4715666657f&chksm=bd2d0d528a5a84446fb88da7590e6d4e5ad06cfebb5cb57a83cf75056007ba29515c85b9a24c&scene=21#wechat_redirect)

  二叉树

  ![二叉树](http://bed.thunisoft.com:9000/ibed/2020/03/24/9aSXfpGWe.png)

平 衡 二 叉 树 ：

- 它 的 左 子 树 和 右 子 树 都 是 平 衡 二 叉 树
- 左 子 树 和 右 子 树 的 高 度 之 差 的 绝 对 值 不 超 过 1

局部性原理：

CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中

- 时间局部性：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问
- 空间局部性：在最近的将来将用到的信息很可能与现在正在使用的信息在空间地址上是临近的
- 顺序局部性（OrderLocality）：在典型程序中，除转移类指令外，大部分指令是顺序进行的

内存读写速度>磁盘读写速度

![内存与磁盘的传输速度.jpg](http://bed.thunisoft.com:9000/ibed/2020/03/24/9aZHX1FGy.jpg)

在连续读取下内存大致是硬盘的6倍

在随机存储下内存大致是硬盘的10万倍

读取磁盘中的数据时间：查找时间（磁头移动到柱面5ms）+ 等待时间（盘片旋转至盘块 4.17ms） + 传输时间（数据传输到内存）

#### 

B树是一种多路平衡查询树，它的每个节点最多包含m个孩子,m被称为B树的阶，一个m阶的B树具有如下几个特征：

- 根结点至少有两个子女
- 每个中间节点都包含k-1个元素和k个孩子，其中 m/2 <= k <= m
- 每一个叶子节点都包含k-1个元素，其中 m/2 <= k <= m
- 所有的叶子结点都位于同一层
- 每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划

![B树](http://bed.thunisoft.com:9000/ibed/2020/03/24/9aSZ3ieC8.png)

**一个m阶的B+树具有如下几个特征**：

- 有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点
- 所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接
- 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。

![B+树](http://bed.thunisoft.com:9000/ibed/2020/03/24/9aSZXq3ai.png)

在数据库的聚集索引（Clustered Index）中，叶子节点直接包含卫星数据。在非聚集索引（NonClustered Index）中，叶子节点带有指向卫星数据的指针。

B树与B+树的区别：[什么是B+树](https://mp.weixin.qq.com/s/jRZMMONW3QP43dsDKIV9VQ)

- B树中无论是中间节点还是叶子节点都包含卫星数据；而B+树种只有叶子节点包含卫星数据
- 单一节点存储更多的元素，B+树比B树更加“矮胖”，IO次数更少
- 所有查询都要查找到叶子节点，B+树比B树查找更加稳定
- 所有叶子节点形成有序链表，B+树便于范围查询

小测试：

#### 聚集索引与非聚集索引实现差异：

##### MyISAM索引：

MyISAM的索引与行记录是分开存储的，叫做**非聚集索引**（UnClustered Index）

其主键索引与普通索引没有本质差异：

- 有连续聚集的区域单独存储行记录
- 主键索引的叶子节点，存储主键，与对应行记录的指针
- 普通索引的叶子结点，存储索引列，与对应行记录的指针
- *MyISAM的表可以没有主键*
- 主键索引与普通索引是两棵独立的索引B+树，通过索引列查找时，先定位到B+树的叶子节点，再通过指针定位到行记录。

![非聚集索引](http://bed.thunisoft.com:9000/ibed/2020/03/24/9aSa3RRqb.png)

##### InnoDB索引：

InnoDB的**主键索引与**行记录是存储在一起的，故叫做**聚集索引**（Clustered Index）：

- 没有单独区域去存储行记录
- 主键索引的叶子节点，存储主键，与对应行记录（而不是指针）
- 普通索引的叶子节点，存储主键（也不是指针）
- InnoDB的表必须要有聚集索引,也只能够有一个，因为数据行在物理磁盘上只能有一份聚集存储

![聚集索引](http://bed.thunisoft.com:9000/ibed/2020/03/24/9aSaaenNh.png)

对于InnoDB表，这里的启示是：

- 不建议使用较长的列做主键，例如char(64)，因为所有的普通索引都会存储主键，会导致普通索引过于庞大；
- 建议使用趋势递增的key做主键，由于数据行与索引一体，这样不至于插入记录时，有大量索引分裂，行记录移动；

**PostgreSQL仅支持非聚集索引**

### 创建索引的规则

- 三星索引
  - where AA and BB and CC...  
  - order by  XX (ASC/DESC)
  - select AA，BB
- 表间关联，
- 字段大小

不适合创建索引的情况：

- 数据量小
- 数据唯一性差的字段不要使用索引
- 字段类型类似text等这种大字段，会占很多存储空间

- 一个长的字符串要如何建立索引
  - 创建前缀索引，必须要前缀具有很好的区分度；select count(distinct left(email,4))  from t
  - 倒序索引，然后再创建前缀索引
  - 创建hash字段索引，需要额外存储和计算，不支持范围查询

创建索引带来的影响：

- 占用磁盘
- 影响更新的效率，插入，删除，更新数据时，索引也需要更新

### 不能命中索引的情况

- is null,is not null  能不能走索引？
- !=  not in 能不能走索引？
- 字段上包含函数;如to_char(d_xxxx,'YYYY-MM-DD') = '2020-01-01'?怎么解决？
- 字段上存在计算；如：n_fs +10<20
- 存在 隐式类型转换？n_fs= '10'
- 查询数据包含大部分数据；数据区分度比较低；怎么解决？
- like 能不能走索引，like 'a%',like '%a',如果不能，要怎么办？
  - 可以使用gin 索引，但要注意建索引要带上gin_trgm_ops
  - gin索引不支持等值和区间查询
  - gin索引单个词的全模糊匹配不走索引，但前后模糊都可以走索引 
  - btree_gin 支持等值和区间查询

[从难缠的模糊查询聊开 - PostgreSQL独门绝招之一 GIN , GiST , SP-GiST , RUM 索引原理与技术背景](https://yq.aliyun.com/articles/68244)

### 什么是联合索引

多个字段上建立的索引，能够加速复核查询条件的检索

- 联合索引建立的顺序有没有关系，查询时where 条件前后顺序有没有影响？
- 联合索引能够满足最左侧查询需求，例如(a, b, c)三列的联合索引，能够加速a | (a, b) | (a, b, c) 三组查询需求。

建立联合索引的原则：

- 如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的
- 如果都需要建立索引，则需要考虑空间，一般字段大的不选择单独建立索引

### postgresql索引维护

表占用空间的大小：

- select  pg_column_size('123')   存储字符'123'需要的字节数
- pg_size_pretty(bigint) 转换成更好理解大小
- select pg_size_pretty(pg_database_size('db_imp'))  ==数据库==使用的磁盘空间
- select pg_size_pretty(pg_relation_size('t_jfkh_rjz')) ，pg_table_size('t_jfkh_rjz')  查看指定==表大小==
- select pg_size_pretty(pg_relation_size('i_jfkh_rjz_c_zfxx_bh'))  查看==单索引大小==
- select pg_size_pretty(pg_total_relation_size('t_jfkh_rjz')) 查看指定==表的总大小==
- select pg_size_pretty(pg_indexes_size('t_jfkh_rjz')) 查看指定表中==所有索引的大小==
- select * from pg_stat_user_indexes 查询索引被使用的次数

查看表中所有的索引信息：

- select * from pg_indexes where tablename='t_jfkh_rjz' and schemaname = 'db_jfkh';

索引的利用率：

pg_stat_user_indexes .idx_scan 可检查利用索引进行扫描的次数；

参考资料：[一文搞定数据库索引](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651962936&idx=1&sn=2f4a97187134ed584273550104672694&chksm=bd2d0be48a5a82f2e5703e55272f6e3ee60954efd8d08b46232c3e24ec5632691ccc66973553&token=331401046&lang=zh_CN&scene=25#wechat_redirect)    [快男之道](http://jd.thunisoft.com/#/./%E5%88%86%E4%BA%AB%E4%BA%A4%E6%B5%81%E6%96%87%E6%A1%A3/090316545098.html)

影响数据库查询速度的原因主要是什么？

- 磁盘IO
- 数据量的大小

磁盘IO的时间包括哪些？

- 寻址时间（也就是磁头指到对应的磁道上差不多5ms）
- 旋转延时（也就是磁盘在磁道上找到对应的扇区，跟磁盘转速有关，差不多2ms）
- 传送时间  磁盘到内存的传输时间，跟数据量有关 32K 大约0.8ms

所以影响数据库查询效率的就主要包括两个部分

- 是否顺序读写，还是随机都写
- 数据量的大小

如何保证顺序读，并且尽量读取更少的数据

- 索引

为什么索引能够保证

- 读取更少的数据，更快的查询到数据

- 索引数据量比正常表数据量小很多
- 一次page一次磁盘IO(B+树优于二叉树)
- 假如一个page就是B+树的一个节点，能够充分的利用预读的特性，极大减少磁盘IO；

